# REACT AND NEXTJS INTRO 😎

### REACT JS AND REACT HOOKS
== REACT JS (MAIN BASE FOR FRONTEND)
==  use client  
==  use server 

==  useFormStatus 
==  useFormState 
==  useEffect

### STYLING AND CSS ✨

== Tailwind CSS
== Daisy UI
== Material UI
== Provider {react-hot-toast}



# NEXTJS 🔥

== It is an react framework use to build the fullstack application.


## INSTALLATION

```javascript
npx create-next-app@latest appName
``` 

## PACKAGES TO BE INSTALLED

```js

npm install @clerk/nextjs@latest @prisma/client@latest @tanstack/react-query@latest @tanstack/react-query-devtools@latest axios@latest openai@latest react-hot-toast@latest react-icons@latest

```


## Tailwind and DaisyUI  🎆

== Install the npm package :-

```js
npm i -D daisyui@latest @tailwindcss/typography@latest prisma@latest
```

== Also add the plugin in 'tailwind.config.js' :-

```javascript

module.exports = {
  ...
  plugins: [require('@tailwindcss/typography'), require('daisyui')]

};
```





## FILE AND FOLDER STRUCTURE

== The folders will contain all our .jsx pages and will be used for routing.



## ROOT LAYOUTS (Required) { layout.js }

== layouts preserve state, remain interactive, and do not re-render. Layouts can also be nested.
== The component should accept a {children} prop that will be populated with a child layout (if it exists) or a page during rendering.

== The root layout { layout.js } is defined at the top level of the app directory and applies to all routes.
== This layout is required and must contain html and body tags, allowing you to modify the initial HTML returned from the server.
== By default { NextJs } will automatically insert the { layout.js } file in our { app directory }.
== When a {layout.js} and {page.js} file are defined in the same folder, the layout will wrap the page.

### CODE SYNTAX FOR {layout.js}. THIS WILL REMAIN ALMOST SAME.

```javascript
// THIS IS THE NESTED LAYOUTS
// 'children' WILL FETCH THE REMAINNG '.jsx' FILE INSIDE OUR FOLDERS.

import { Inter } from "next/font/google";
import Navbar from "@/components/Navbar";
import Footer from "@/components/Footer";
import "./globals.css";
import { SpeedInsights } from "@vercel/speed-insights/next";
import Providers from "./providers";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "NextJs App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className} style={{fontFamily:"monospace"}}>

        <Navbar></Navbar>
        <Providers>{children}</Providers>
        <Footer></Footer>
      </body>
    </html>
  ); 
} 

```
### -------------------------------

## ROUTES

== By 'Link' Component we can add routes to our page.
==> You can use it by importing it from next/link, and passing a href prop to the component:
== HERE, { Clients, Drinks, Prisma, Task,  } IS EXAMPLE OF { ROUTE SEGMENTS FOLDER }.
== THIS FOLDER IS CALLED { ROUTE SEGEMNTS FOLDER }
== Create a folder in the 'app' directory and inside it create a page.js (.jsx) file. The folder name becomes the route segment in the project.

```js
// SIMPLE EXAMPLE TO USE 'LINK' COMPONENTS

"use client";

import Link from "next/link";
import "./globals.css";


async function HomePage(){

    return (
      <div className="homeContent flex items-center justify-center mt-8 flex-col gap-10">
        <h1 className="text-3xl">Get Started with NextJS</h1> 
        <Link href="/clients" className="btn btn-accent">
            <h1>Get Started</h1>
        </Link>        
      </div>
    );
  };
  
  export default HomePage;

```


## LOADING UI (loading.jsx) 

== THIS IS PRESENT INSIDE { ROUTE SEGEMNTS FOLDER  } WHICH WILL AUTOMATICALLY WRAP THE { page.jsx }
== The special file loading.js helps you create meaningful Loading UI with React.
== With this convention, you can show an instant loading state from the server while the content of a route segment loads. The new content is automatically swapped in once rendering is complete.

### SYNTAX FOR   (loading.jsx)
```javascript
function Loading(){

    return (
        <div className="flex items-center justify-center mt-20 mb-20">
            <span className="loading loading-dots loading-lg"></span>
        </div>
         
    );
}

export default Loading;
```


## ---------------------------------------------------

## ERROR HANDLING UI (error.jsx) 

== THE SIMPLE EXAMPLE OF HANDLING THE ERROR BY USING { error.jsx } FILE IS :==>


```javascript
"use client";

function error(error){

    return (
        <div className="flex items-center justify-center mt-28">
            {/* <h1>There was an {error}...</h1> */}
            <h1 className="text-3xl">{error.error.message}</h1>
        </div>
    );
}
export default error;

```



## ---------------------------------------------------------------------------------------------------------//



## NESTED LAYOUTS 

== THIS IS THE SIMPLE EXAMPLE OF NESTED LAYOUTS
== { /Drinks/layout.jsx  ||  /Drinks/loading.jsx  ||  /Drinks/error.jsx }   THIS IS THE EXAMPLE OF NESTED LAYOUTS
== NESTED Layouts preserve state, remain interactive, and do not re-render. Layouts can also be nested.


```javascript
function DrinksLayoutPage({children}){
    return (
            <h1 className="text-2xl mb-11">Drinks Layout Page</h1>
            {children}
    );
} 

export default DrinksLayoutPage;
```

## ---------------------------------------------------------------------------------------------//




 


## SERVER COMPONENTS 

== BY DEFAULT, NEXTJS USES SERVER COMPONENTS !!!!
== Fetching Data: They can fetch data directly from the server, avoiding the need for additional API calls from the client.
== Rendering on the Server: Server components are rendered on the server, which means they don't include client-side JavaScript in the final output sent to the browser.
== BASICALLY, ALL THE HTTPS REQUEST { GET, POST, PUT, PATCH, DELETE } ARE NOTHING BUT SERVER COMPONENTS.


## CLIENT COMPONENTS 

== Client Components allow you to write interactive UI that is prerendered on the server and can use client JavaScript to run in the browser.
== Interactivity: Client Components can use use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.
== Browser APIs: Client Components have access to browser APIs
== To use Client Components, you can add the React "use client" directive at the top of a file, above your imports.
== "use client" is used to declare a boundary between a Server and Client Component modules.




## Fetch Data in Server Components 🚀🚀🚀

== just add async and start using await 
== RATHER, WE CAN USE {AXIOS} FOR FETCHING AN API'S 
== the same for db



## -------------------------------------------------------------------------------------------//
// THIS IS THE SIMPLE AXIOS METHOD TO FETCH THE API.

```javascript
import axios from "axios";

async function fetchData(){
  await new Promise((resolve) => {setTimeout(resolve,1000)});
  try{
    let response = await axios.get(url);
    let result = response.data; 
    console.log(result);
    return result;
  }
  catch(error){
    throw new Error("Failed to fetch the APIs")
  };

}

async function HandleFetchData(){
  let result = await fetchData();
  return (
    <h1>{result.content}</h1>
  );
}
```


## -------------------------------------------------------------------------------------------//

## DYNAMIC ROUTES 

== A Dynamic Segment can be created by wrapping a folder's name in square brackets: [folderName]. For example, [id]
== Dynamic Segments are passed as the {params} prop to layout, page, route  functions.
== For example, a { Drinks } could include the following route {  app/Drinks/[id]/page.jsx  } where [id] is the Dynamic Segment for Drinks Lists.


// THIS IS AN SIMPLE EXAMPLE OF DYNAMIC ROUTING.

##### app/Drinks/[id]/page.jsx

```javascript


function DynamicDrinksPage({ params }){
  console.log(params);

  return (
    <h1>{params.id}</h1>
  );
}
```

## -------------------------------------------------------------------------------------------//









## PRISMA  💰

== Prisma ORM is a database toolkit that simplifies database access in web applications.
==  It allows developers to interact with databases using a type-safe and auto-generated API, making database operations easier and more secure.

===> Prisma server: A standalone infrastructure component sitting on top of your database.
===> Prisma client: An auto-generated library that connects to the Prisma server and lets you read, write and stream data in your database. It is used for data access in your applications.

## -------------------------------------------------------------------------------------------//


## INSTALLATION 

```javascript

npm i prisma --save-dev
npm i prisma @prisma/client
npx prisma init

```

==  This creates a new prisma directory with your Prisma schema file and configures SQLite as your database

## -------------------------------------------------------------------------------------------//


## SETUP PRISMA {GENERATOR AND DATASOURCE} 

== Now, inside { schema.prisma } Setup and modify the { generator and datasource }


```javascript

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["prismaSchemaFolder"]  
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

```

## -------------------------------------------------------------------------------------------//


## .env and .gitignore 

```javascript
DATABASE_URL="file:./dev.db"      { .env }
```
== ADD  { .env } IN { .gitignore }

## -------------------------------------------------------------------------------------------//

== This in turn initializes a new PrismaClient instance each time due to hot reloading that creates a connection to the database.
== CREATE NEW FOLDER { utils } and THEN ADD { db.ts } FILE INSIDE AN FOLDER.



## {utils/db.ts} 

```javascript

import { PrismaClient } from '@prisma/client';

const prismaClientSingleton = () => {
  return new PrismaClient()
}

declare const globalThis: {
  prismaGlobal: ReturnType<typeof prismaClientSingleton>;
} & typeof global;

const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma

```

## -------------------------------------------------------------------------------------------//

## PRISMA MODEL 

== Prisma models are defined in the Prisma schema
== the term "model" refers to an abstraction that maps to a table in your database.
== Each model in the Prisma schema corresponds to a table in the database,
== and each field within a model corresponds to a column in that table


```javascript

model Task {
  id Int @id @default(autoincrement())
  content String
  createdAt DateTime @default(now())
  completed Boolean @default(true)
}

```

## -------------------------------------------------------------------------------------------//


## RUNNING LOCALLY 

```javascript
// WHENEVER WE MAKE CHANGES IN OUR SCHEMA RUN THE FOLLOWING CODE :=
npx prisma migrate dev


// Prisma Studio is a visual editor for the data in your database.
npx prisma studio

https://localhost:5555
```


### --------------------------------------------------------------------------------------------//


### HOST OUR DATABASE ON CLOUD   (Render OR PlanetScale)

```javascript

WE WILL HOST OUR DATABASE ON CLOUD 
set DATABASE_URL in .env

'Render' will provide you an external URL update your 'DATABASE_URL' in .env
CHANGE PROVIDERS TO "postgresql" 

```

```javascript
// When done with URL. Run the following code 
npx prisma db push
```



## CONNECT OUR DATABASE WITH FRONTEND AND BACKEND 

== INSIDE THE { page.jsx }



```javascript
import prisma from "@/utils/db";

async function prismaHandlers(){
    try{
       await prisma.task.create({
        data:{
            content:'Hey Just trying CRUD operation'
        }
    })
 
    let allTasks = await prisma.task.findMany({
        orderBy:{
            createdAt:"asc"
        }
    });
    return allTasks; 
    }
    catch(error){
        throw new Error("Failed to connect with DataBAse")
    }
    
}

async function prismaPage(){

  let result = await prismaHandlers();
  return (
    <h1>{result.content}</h1>
  );

}
```

## -------------------------------------------------------------------------------------------//



## CRUD OPERATION 

### REFER {prisma.io} FOR MORE INFORMATION OF CRUD OPERATION AND PRISMA.

## -------------------------------------------------------------------------------------------//

### CREATE OPERATION

```javascript
import prisma from "@/utils/db"; 
import {revalidatePath} from "next/cache"; 
import { redirect } from "next/navigation";  

async function handleAction(formData){
    "use server"
    let content = formData.get(' inputName ');
    console.log(content);

    try{
       await prisma.tableName.create({
        data:{
            content,
        }
    });
    revalidatePath('/'); 
    }
    catch(error){
        throw new Error("Failed to create task");
    }
}

async function createTask(){

    return (
        <div>
            <form action={handleAction}>
                <input name="inputName" placeholder="enter task" required>
                <button type="submit" value="Create Task..."/>
            </form>
        </div>
    );
}
```
== 'use server' directive is used to store the user input data.
== 'formData' can be used only inside the 'use server' directive
== 'form' tag should take an attribute of 'action' and passed the function 'handleAction'

## -------------------------------------------------------------------------------------------//


### READ OPERATION

```javascript

import prisma from "@/utils/db.ts";

async function handleAction(){
    try{
        let result = await prisma.tableName.findMany({
        where:{
            id:3
        },
        select:{
              column1Name:true,
              column2Name:true
           }
    });
    return result;
    }
    catch(error){
        throw new Error("Email already exist")
    };
};

async function readTask(){

    let result = await handleAction();
    return (
        <div>
            <h1>{result.column1Name}</h1>
            <h1>{result.column2Name}</h1>
        </div>
    );
}
```

== By 'findMany' we can get all the tasks as return.
== We also have 'findUnique' method and just passed the 'where' condition.

## -------------------------------------------------------------------------------------------//


### UPDATE OPERATION



```javascript

import prisma from "@/utils/db"; 
import {revalidatePath} from "next/cache"; 
import { redirect } from "next/navigation";  


async function handleAction(formData){
    "use server"
    let editTask = formData.get('editContent');
    let id = Number(formData.get('taskId'));

    try{
        await prisma.taskList.update({
        where:{
            id, 
        },
        data:{
            content:editTask,
        }
    });

    redirect('/Task');
    }
    catch(error){
        throw new Error("Failed to edit Task");
    };
    
};


async function editForm({id}){

    return (

        <div>
            <form action={handleAction}>

                <input type="hidden" name="taskId" value={id}/>
                <input
                    name="editContent"
                    type="text" 
                    placeholder="Edit the task" 
                />
                <button type="submit" >Edit Task</button>

            </form>
        </div>
    );
}
```


```javascript
<input type="hidden" name="taskId" value={id}/>
```

== THIS INPUT TAG WHICH IS SET HIDDEN, WILL GET US THE ' taskId ' OF SELECTED TASK.




## -------------------------------------------------------------------------------------------//


### DELETE OPERATION


```javascript

import prisma from "@/utils/db"; 
import {revalidatePath} from "next/cache"; 
import { redirect } from "next/navigation";  


async function handleAction(formData){
    "use server" 
    let id = Number(formData.get('taskId'));

    try{
    await prisma.tableName.delete({
        where:{
            id,
        }
    });
    redirect('/Task')
    }
    catch(error){
        throw new Error("failed to delete the task");
    };
};


async function DeleteForm(props){

    return (
        <form action={handleAction}>
            <input type="hidden" name="taskId" value={props.id}/>
            <button type="submit">Delete</button>
        </form>
        
    );
}

```

```javascript
<input type="hidden" name="taskId" value={id}/>
```

== AGAIN, WE HAVE USED THE SAME METHOD OF 'INPUT TAG', WHICH WILL RETURN US THE ' TASKID ' WHICH HAS TO BE DELETED.


## -------------------------------------------------------------------------------------------//

## Server Actions

== Server Actions are asynchronous functions that are executed on the server. 
== They can be used in Server and Client Components to handle form submissions and data mutations in Next.js applications.



### FORMS   (formData)

==  'form' element to allow Server Actions to be invoked with the {action} attribute.
== the action automatically receives the FormData object.
== You don't need to use React useState to manage fields, instead, you can extract the data using the native FormData methods.

```javascript

import React from "react";
import {revalidatePath} from "next/cache";
import {redirect} from "next/Navigatiom";

async function handleAction(formData){
    "use server"
    let content = formData.get(' content ');

    // mutate data
    // revalidate cache
    revalidatePath("/")
};

async function taskForm(){

    return (
        <form action={handleAction}>
            <input type="text" name="content" placeholder="Enter the content"/>
            <button type="submit" value="create task"/>
        </form>
    );
}

```


### PENDING STATES  (useFormStatus)

== You can use the React useFormStatus hook to show a pending state while the form is being submitted.
== "useFormStatus" returns the status for a specific <form>, so it must be defined as a child of the <form> element.
== It can be used inside an "client components".

```js

app/components/Button.jsx

'use client'
import { useFormStatus } from 'react-dom'
 
export function SubmitButton() {
  const { pending } = useFormStatus();
 
  return (
    <button type="submit" disabled={pending}>
      {pending ? "Please Wait..." : "Task Created"}
    </button>
  )
};

```

== SubmitButton can then be nested in any form:


## ----------------------------------------------------


### FORM STATE MANAGEMENT   (useFormState)

== Once the fields have been validated on the server, you can return a serializable object in your action
== and use the React useFormState hook to show a message to the user.


```js

utils/action.jsx

'use server'
import prisma from "@/utils/db.ts";
import {revalidatePath} from "next/cache";
 
export async function handleAction(prevState, formData) {
    "use server"
    let content = formData.get(' content ');
    try{
        await prisma.tableName.findMany();
        revalidatePath('/');
        return ({msg:"Success..."});
    }
    catch(error){
        return ({msg:"Error occured"});
    };
};

```
== Then, you can pass your action to the 'useFormState' hook and use the returned state to display an error message.

```js

'use client'
 
import { useFormState } from 'react-dom'
import { handleAction } from '@/app/actions'
import toast from "react-hot-toast";
 
const initialState = {
  message: null,
}
 
export function TaskForm() {
  
  let [state, formAction] = useFormState(handleAction,initialState);

    useEffect(() => {
        if (state.message === 'error') {
          toast.error('there was an error');
          return;
        }
        if (state.message) {
          toast.success('task created....');
        }
      }, [state]);

      return (
        <form action={formAction}>
            <input name="content">
            <button type="submit">
        </form>
      );
}

```


### ------------------------------------------------------------

## PROVIDERS

```js
npm install react-hot-toast
```

##### app/providers.js

```js

'use client';
import { Toaster } from 'react-hot-toast';

const Providers = ({ children }) => {
  return (
    <>
      <Toaster />
      {children}
    </>
  );
};
export default Providers;

```

##### app/layout.js

```js


import Providers from './providers';

export default function RootLayout({ children }) {
  return (
    <html lang='en'>
      <body className={inter.className}>
        <Navbar />
        <main className='px-8 py-20 max-w-6xl mx-auto'>
          <Providers>{children}</Providers>
        </main>
      </body>
    </html>
  );
}

```
### --------------------------------------------------

### LOCAL BUILD

##### package.json


```javascript
"build": "npx prisma generate && next build",
```

== START THE 'LOCAL BUILD' WHEN YOUR DB IS HOST ON CLOUD.

```javascript
npm run build
npm start
```

### NOTE 

== WHEN WE ARE BUILDING LOCALLY, CHECK WHICH ROUTE SEGMENT FOLDER IS STATIC OR DYNAMIC.

```javascript
○  (Static)   prerendered as static content
ƒ  (Dynamic)  server-rendered on demand
```


== IF WE NEED TO CHANGE ANY ROUTE SEGMENT FOLDER TO DYNAMIC.
== THEN INSERT THE FOLLOWING CODE IN  'page.jsx'

##### page.jsx

```js

export const dynamic = 'force-dynamic';
```

## DEPLOY  (VERCEL) 🌐

== sign up for account
== create github repo
== IMPORT THE GITHUB REPO TO HOST OUR WEBAPP

== COMMIT THE CHANGES, TO APPLY CHANGES IN OUR LIVE APP.




## --------------------------------------------------

## CLERK AUTHENTICATION

== create account
== create new application
== complete Next.js setup


```js
npm install @clerk/nextjs
```


```js
// CREATE (.env.local) FILE AND UPLOAD NECESSARY VAR PROVIDED BY CLERK

NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = your_publishable_key;
CLERK_SECRET_KEY = your_secret_key;

```

== Add (.env.local) IN (.gitignore)


### middleware.ts


```js
// CREATE THIS FILE IN ROOT DIRECTORY

import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';
 
// public routes in our case '/'
const isPublicRoute = createRouteMatcher(['/']);
 
export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) auth().protect();
});
 
export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};


```

### app/layout.js

== Wrap the HTML element inside <ClerkProvider>

```js
// UPDATE layout.js file

import { ClerkProvider } from "@clerk/nextjs";

export default function RootLayout({ children }) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body className={inter.className}>
          <main className="text-white" style={{ fontFamily: "monospace" }}>
            <Providers>{children}</Providers>
          </main>
        </body>
      </html>
    </ClerkProvider>

  );
};

```



## CLERK COMPONENTS AND FUNCTIONS


### CURRENTUSER AND USERBUTTON FUNCTION

```js
import { UserButton } from "@clerk/nextjs";
import { currentUser } from "@clerk/nextjs/server";

async function Navprofile(){

    // THIS WILL RETURN US THE CURRENT USER WHICH IS AUTENTICATED.
    let user = await currentUser();
    console.log(user);
    return (
        <div className="px-4 flex items-center gap-2 relative top-48">
             {/* After SignOut we will redirect to ' redirectUrl '  */}
            <UserButton redirectUrl="/"></UserButton>
            <p className="text-xl text-white">{user.emailAddresses[0].emailAddress}</p>
        </div>
    );
};

export {Navprofile};

```

### UserProfile Page

app/Profile/page.jsx

```js

import { UserProfile } from '@clerk/nextjs';
const UserProfilePage = () => {
  return <UserProfile />;
};
export default UserProfilePage;

```




### THEME TOGGLE USING DAISY UI

```js
// tailwind.config.js

{
  daisyui: {
    themes: ['winter', 'dracula'],
  },
}

// CHECK DAISY UI FOR MORE THEME
```

Create ThemeToggle.jsx component

```js
//  /components/ThemeToggle.jsx

'use client';
import { BsMoonFill, BsSunFill } from 'react-icons/bs';
import { useState } from 'react';

const themes = {
  winter: 'winter',
  dracula: 'dracula',
};

const ThemeToggle = () => {
  const [theme, setTheme] = useState(themes.winter);

  const toggleTheme = () => {
    const newTheme = theme === themes.winter ? themes.dracula : themes.winter;
    document.documentElement.setAttribute('data-theme', newTheme);
    setTheme(newTheme);
  };

  return (
    <button onClick={toggleTheme} className='btn btn-sm btn-outline'>
      {theme === 'winter' ? (
        <BsMoonFill className='h-4 w-4 ' />
      ) : (
        <BsSunFill className='h-4 w-4' />
      )}
    </button>
  );
};
export default ThemeToggle;


```



### TO CREATE A COMMON (layout.js) FILE FOR ALL ROUTE SEGMENT FOLDER

Create (app/(dashboard)/layout.jsx). This will be the common layout.js file for all route segment folder.

```js
function LayoutPage({children}){

  return(
    <div>
      {children}
    </div>
  );
}

```



## REACT QUERY AND NEXTJS


### INSTALLATION

```js
npm i @tanstack/react-query @tanstack/react-query-devtools
```


### BASIC SETUP

Update  app/providers.js file

```JS
// providers.js

'use client';
import { Toaster } from 'react-hot-toast';
import React from 'react'; 
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

function Providers({ children }) {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      })
  );
  return (
    <QueryClientProvider client={queryClient}>
      <Toaster />
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
};

export default Providers;

```


### USING useQuery and useMutation HOOKS

Now to use this hooks in our Route segment folder[Nextjs.md](https://github.com/user-attachments/files/16393531/Nextjs.md)
